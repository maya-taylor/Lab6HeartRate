
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import sys, time, math
import serial

import re
import pygame

#initialixing pygame
pygame.init()
pygame.mixer.init()



#serious mode: only graphing
#non-serious mode flappy bird

import tkinter as tk
def on_option_select():
    selected = selected_option.get()
    result_label.config(text=f"Selected Option: {selected}")
root = tk.Tk()
root.title("Select you Heartrate Monitoring Mode")
root.geometry("400x300")
# Create a StringVar to hold the selected option
selected_option = tk.StringVar()
# Create the dropdown menu
options = ["Serious Mode", "Game Mode"]
dropdown = tk.OptionMenu(root, selected_option, *options)
dropdown.pack(pady=10)
# Add a button to display the selected option
show_button = tk.Button(root, text="Show Selection", command=on_option_select)
show_button.pack()
# Label to display the selected option
result_label = tk.Label(root, text="")
result_label.pack()
root.mainloop()

serious_flag = 0

if selected_option.get() == 'Serious Mode':
    serious_flag = 1
    print("Serious")

xsize=100

avg_size = 10
xdata, y1data, y1avgdata = [], [], []


#noisebank!!!


for i in range(avg_size):
    y1data.append(80)



ser = serial.Serial(
    port='COM11', #change to whichever serial port we end up using (e.g. COM5)
    baudrate=115200,
    parity=serial.PARITY_NONE,
    stopbits=serial.STOPBITS_TWO,
    bytesize=serial.EIGHTBITS
)
ser.isOpen()    


def data_gen():
    t = data_gen.t
    while True:
        strin = ser.readline()
        print(strin) 
        t+=1
        val1= float(strin[3:])
        yield t, val1




def run(data):
    # update the data
    t,y1 = data
    if t>-1:
        xdata.append(t)
        if y1 > 250:
            y1data.append(y1data[t+avg_size])
        else:
            y1data.append(y1)

        y1avg = np.sum(y1data[t:t+avg_size])/avg_size
        y1avgdata.append(y1avg)

        

        if t>xsize: # Scroll to the left.
            ax.set_xlim(t-xsize, t)
            t1.set_position(((t-xsize+10), 220))
        line1.set_data(xdata, y1data[10:])
        line2.set_data(xdata, y1avgdata)
        l1.get_texts()[0].set_text(f"Heartrate = {round(y1data[t+avg_size],2)} BPM")
        l2.get_texts()[0].set_text(f"Avg Heartrate = {round(y1avg,2)} BPM")
    return line1, line2,


def on_close_figure(event):
    sys.exit(0)



if serious_flag == 1: 
    data_gen.t = -1
    fig = plt.figure()
    fig.canvas.mpl_connect('close_event', on_close_figure)
    ax = fig.add_subplot(111)
    line1, = ax.plot([], [], label='BPM', lw=2)
    line2, = ax.plot([], [], label='BPMavg', lw=2)
    ax.set_ylim(0, 250)
    ax.set_xlim(0, xsize)
    ax.set_xlabel('Readings')
    ax.set_ylabel('Heartrate (BPM)')
    ax.set_title('Heartrate over Time')
    ax.grid()
    l1 = ax.legend(handles = [line1], loc = 1)
    ax.add_artist(l1)
    l2 = ax.legend(handles=[line2], loc = 4)

    ani1 = animation.FuncAnimation(fig, run, data_gen, blit=False, interval=100, repeat=False)
    plt.show()
else:
    # still set up same graph style (maybe no graph lines though)
    # could even still label with Heartrate (BPM)
    print("hi")
    # add recangles with random heights (two types at a time - top rect and bottom rect)
    # move them along graph (in run - should make separate run_game func)
    # if the current t and BPM vals are in the rectangles, you lose
    # space between rectangles (how long to wait before adding a new one) can be somewhat random
    # height between rectangles can also be somewhat random
    # should start moving graph earlier, and keep location of current val towards beginning
    # look into having an image at the current val - you probably can have images on graphs